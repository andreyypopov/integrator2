<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Integrator: NumericalIntegrator3D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Integrator<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">Computation of integrals of fundamental solution of the Laplace equation and its gradient</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_numerical_integrator3_d.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_numerical_integrator3_d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NumericalIntegrator3D Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class responsible for the whole numerical integration procedure.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6beece1578d8737b31db031f46a258c8" id="r_a6beece1578d8737b31db031f46a258c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6beece1578d8737b31db031f46a258c8">NumericalIntegrator3D</a> (const <a class="el" href="class_mesh3_d.html">Mesh3D</a> &amp;mesh_, const <a class="el" href="struct_quadrature_formula3_d.html">QuadratureFormula3D</a> &amp;qf_)</td></tr>
<tr class="memdesc:a6beece1578d8737b31db031f46a258c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_numerical_integrator3_d.html" title="Class responsible for the whole numerical integration procedure.">NumericalIntegrator3D</a> object.  <br /></td></tr>
<tr class="separator:a6beece1578d8737b31db031f46a258c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528ef4eaa86844a2cdaaca811e430be9" id="r_a528ef4eaa86844a2cdaaca811e430be9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528ef4eaa86844a2cdaaca811e430be9">~NumericalIntegrator3D</a> ()</td></tr>
<tr class="memdesc:a528ef4eaa86844a2cdaaca811e430be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="class_numerical_integrator3_d.html" title="Class responsible for the whole numerical integration procedure.">NumericalIntegrator3D</a> object.  <br /></td></tr>
<tr class="separator:a528ef4eaa86844a2cdaaca811e430be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece2676a79cd5aa447a292aafe50cb9" id="r_a3ece2676a79cd5aa447a292aafe50cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ece2676a79cd5aa447a292aafe50cb9">setFixedRefinementLevel</a> (int refinementLevel=0)</td></tr>
<tr class="memdesc:a3ece2676a79cd5aa447a292aafe50cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the fixed refinement level for the whole mesh.  <br /></td></tr>
<tr class="separator:a3ece2676a79cd5aa447a292aafe50cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c6dd14524a04964910b70612b1caff" id="r_aa8c6dd14524a04964910b70612b1caff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8c6dd14524a04964910b70612b1caff">prepareTasksAndMesh</a> (const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;simpleNeighborsTasks, const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;attachedNeighborsTasks, const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;notNeighborsTasks)</td></tr>
<tr class="memdesc:aa8c6dd14524a04964910b70612b1caff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Necessary preparations (mesh and tasks) before integral calculation.  <br /></td></tr>
<tr class="separator:aa8c6dd14524a04964910b70612b1caff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fe152d3e7a9ad1de95857f5191b29d" id="r_a22fe152d3e7a9ad1de95857f5191b29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22fe152d3e7a9ad1de95857f5191b29d">gatherResults</a> (<a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt; &amp;results, <a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType) const</td></tr>
<tr class="memdesc:a22fe152d3e7a9ad1de95857f5191b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum up the results of integration over refined cells (for a specific type of neighbors) into the vector for original task results.  <br /></td></tr>
<tr class="separator:a22fe152d3e7a9ad1de95857f5191b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1960a91f376ae611a204003b1e25708" id="r_af1960a91f376ae611a204003b1e25708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1960a91f376ae611a204003b1e25708">refineMesh</a> (<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> updateTasksNeighborType=<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfda5e543256c480ac577d30f76f9120eb74">neighbour_type_enum::undefined</a>)</td></tr>
<tr class="memdesc:af1960a91f376ae611a204003b1e25708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh refinement (whole mesh or specific cells)  <br /></td></tr>
<tr class="separator:af1960a91f376ae611a204003b1e25708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6654d6637c0861803f971f1d148f3a" id="r_a9e6654d6637c0861803f971f1d148f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e6654d6637c0861803f971f1d148f3a">resetMesh</a> ()</td></tr>
<tr class="memdesc:a9e6654d6637c0861803f971f1d148f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-initialization of mesh data using the original mesh in <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object.  <br /></td></tr>
<tr class="separator:a9e6654d6637c0861803f971f1d148f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bdb368b126eb637bfcf71ea970a962" id="r_af9bdb368b126eb637bfcf71ea970a962"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9bdb368b126eb637bfcf71ea970a962">determineCellsToBeRefined</a> (const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt; &amp;restTasks, const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; *tasks, <a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType)</td></tr>
<tr class="memdesc:af9bdb368b126eb637bfcf71ea970a962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the list of indices of cells which require further refinement, using the list of integrals which have not converged.  <br /></td></tr>
<tr class="separator:af9bdb368b126eb637bfcf71ea970a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc832bfc967e32f463dc8cebdf14404" id="r_a2bc832bfc967e32f463dc8cebdf14404"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bc832bfc967e32f463dc8cebdf14404">getGaussPointsNumber</a> () const</td></tr>
<tr class="memdesc:a2bc832bfc967e32f463dc8cebdf14404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Gauss Points.  <br /></td></tr>
<tr class="separator:a2bc832bfc967e32f463dc8cebdf14404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59c7d39fabdc91179608d50926e9d3d" id="r_ad59c7d39fabdc91179608d50926e9d3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad59c7d39fabdc91179608d50926e9d3d">getQuadratureFormulaOrder</a> () const</td></tr>
<tr class="memdesc:ad59c7d39fabdc91179608d50926e9d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order of the specified quadrature formula.  <br /></td></tr>
<tr class="separator:ad59c7d39fabdc91179608d50926e9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6569bfcf131ae540cf3c434ab8455da1" id="r_a6569bfcf131ae540cf3c434ab8455da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_numerical_integrator3d_8cuh.html#a9ab58cb389e76d256ba909cefae8d806">error_control_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6569bfcf131ae540cf3c434ab8455da1">getErrorControlType</a> () const</td></tr>
<tr class="memdesc:a6569bfcf131ae540cf3c434ab8455da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of error control.  <br /></td></tr>
<tr class="separator:a6569bfcf131ae540cf3c434ab8455da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a5601c741c6f0f9ef489201cb4e52b" id="r_aa4a5601c741c6f0f9ef489201cb4e52b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a5601c741c6f0f9ef489201cb4e52b">getRefinedTasks</a> (<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType) const</td></tr>
<tr class="memdesc:aa4a5601c741c6f0f9ef489201cb4e52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of integration tasks for refined cells (for a specific type of neighbor cells)  <br /></td></tr>
<tr class="separator:aa4a5601c741c6f0f9ef489201cb4e52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ddb7fea8012d8e4442a66bbc4e9d86" id="r_ac3ddb7fea8012d8e4442a66bbc4e9d86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3ddb7fea8012d8e4442a66bbc4e9d86">getResults</a> (<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType) const</td></tr>
<tr class="memdesc:ac3ddb7fea8012d8e4442a66bbc4e9d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of results of integration for refined cells (for a specific type of neighbor cells)  <br /></td></tr>
<tr class="separator:ac3ddb7fea8012d8e4442a66bbc4e9d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d40cf4a60a8f2a42902ea13c99e33a" id="r_a62d40cf4a60a8f2a42902ea13c99e33a"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62d40cf4a60a8f2a42902ea13c99e33a">getRefinedVertices</a> () const</td></tr>
<tr class="memdesc:a62d40cf4a60a8f2a42902ea13c99e33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of refined vertices.  <br /></td></tr>
<tr class="separator:a62d40cf4a60a8f2a42902ea13c99e33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732baba2145a1bb794a104a19704a09e" id="r_a732baba2145a1bb794a104a19704a09e"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a732baba2145a1bb794a104a19704a09e">getRefinedCells</a> () const</td></tr>
<tr class="memdesc:a732baba2145a1bb794a104a19704a09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of refined cells.  <br /></td></tr>
<tr class="separator:a732baba2145a1bb794a104a19704a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e7e86b9399d3c88decf212101ed473" id="r_a75e7e86b9399d3c88decf212101ed473"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e7e86b9399d3c88decf212101ed473">getRefinedCellMeasures</a> () const</td></tr>
<tr class="memdesc:a75e7e86b9399d3c88decf212101ed473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of measures (areas) of refined cells.  <br /></td></tr>
<tr class="separator:a75e7e86b9399d3c88decf212101ed473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be924a775975731f2bc587a5da4459c" id="r_a5be924a775975731f2bc587a5da4459c"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5be924a775975731f2bc587a5da4459c">getCellsToBeRefined</a> () const</td></tr>
<tr class="memdesc:a5be924a775975731f2bc587a5da4459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of indices of cells which are to be refined.  <br /></td></tr>
<tr class="separator:a5be924a775975731f2bc587a5da4459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242109ec3a41e2d36705b8502f32ac7c" id="r_a242109ec3a41e2d36705b8502f32ac7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242109ec3a41e2d36705b8502f32ac7c">getIntegralsConverged</a> (<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType)</td></tr>
<tr class="memdesc:a242109ec3a41e2d36705b8502f32ac7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector of flags which show whether the integration of the task has already converged (for a specific type of neighbor cells)  <br /></td></tr>
<tr class="separator:a242109ec3a41e2d36705b8502f32ac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f91fd30d521e4a3b95441c67dd9b0c1" id="r_a1f91fd30d521e4a3b95441c67dd9b0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f91fd30d521e4a3b95441c67dd9b0c1">getRefinementsRequired</a> (<a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType)</td></tr>
<tr class="memdesc:a1f91fd30d521e4a3b95441c67dd9b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector with number of required refinements for each cell (for a specific type of neighbor cells)  <br /></td></tr>
<tr class="separator:a1f91fd30d521e4a3b95441c67dd9b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac3e035ac81e89a77573f011b845d9fd8" id="r_ac3e035ac81e89a77573f011b845d9fd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3e035ac81e89a77573f011b845d9fd8">updateTasks</a> (const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;originalTasks, <a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a> neighborType)</td></tr>
<tr class="memdesc:ac3e035ac81e89a77573f011b845d9fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new integration tasks for the refined cells, based on the the existing list of tasks for parent cells <br  />
  <br /></td></tr>
<tr class="separator:ac3e035ac81e89a77573f011b845d9fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8235749e20de0d7f64cbab82868f7e52" id="r_a8235749e20de0d7f64cbab82868f7e52"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8235749e20de0d7f64cbab82868f7e52">GaussPointsNum</a></td></tr>
<tr class="memdesc:a8235749e20de0d7f64cbab82868f7e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Gaussian points in the quadrature formula.  <br /></td></tr>
<tr class="separator:a8235749e20de0d7f64cbab82868f7e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd6c1af3c33516e17a55b11e3e479fa" id="r_a8fd6c1af3c33516e17a55b11e3e479fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_mesh3_d.html">Mesh3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fd6c1af3c33516e17a55b11e3e479fa">mesh</a></td></tr>
<tr class="memdesc:a8fd6c1af3c33516e17a55b11e3e479fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object with the original surface mesh.  <br /></td></tr>
<tr class="separator:a8fd6c1af3c33516e17a55b11e3e479fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae8cdb315882b26d2cd46db41d55011" id="r_a0ae8cdb315882b26d2cd46db41d55011"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_quadrature_formula3_d.html">QuadratureFormula3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae8cdb315882b26d2cd46db41d55011">qf</a></td></tr>
<tr class="memdesc:a0ae8cdb315882b26d2cd46db41d55011"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quadrature formula selected for numerical integration.  <br /></td></tr>
<tr class="separator:a0ae8cdb315882b26d2cd46db41d55011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab706eea15d5ee8eadebf211d122b4723" id="r_ab706eea15d5ee8eadebf211d122b4723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; <a class="el" href="cuda__math_8cuh.html#a16b7f1b886fa3763a23e6ae41602aa63">Point3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab706eea15d5ee8eadebf211d122b4723">refinedVertices</a></td></tr>
<tr class="memdesc:ab706eea15d5ee8eadebf211d122b4723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector of coordinates of refined vertices.  <br /></td></tr>
<tr class="separator:ab706eea15d5ee8eadebf211d122b4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6575f1d859ebbd681dbe90b4e86dfa" id="r_a8a6575f1d859ebbd681dbe90b4e86dfa"><td class="memItemLeft" align="right" valign="top">int2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a6575f1d859ebbd681dbe90b4e86dfa">verticesCellsNum</a></td></tr>
<tr class="memdesc:a8a6575f1d859ebbd681dbe90b4e86dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current numbers of vertices and cells in the refined mesh stored on the host.  <br /></td></tr>
<tr class="separator:a8a6575f1d859ebbd681dbe90b4e86dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade540c948ce982e88f24b5716828a4a1" id="r_ade540c948ce982e88f24b5716828a4a1"><td class="memItemLeft" align="right" valign="top">int2 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade540c948ce982e88f24b5716828a4a1">refinedVerticesCellsNum</a> = nullptr</td></tr>
<tr class="memdesc:ade540c948ce982e88f24b5716828a4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current numbers of vertices and cells in the refined mesh stored on the device.  <br /></td></tr>
<tr class="separator:ade540c948ce982e88f24b5716828a4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fb545a69963a1653356bdf274a4b1e" id="r_a01fb545a69963a1653356bdf274a4b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01fb545a69963a1653356bdf274a4b1e">refinedCells</a></td></tr>
<tr class="memdesc:a01fb545a69963a1653356bdf274a4b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector of vertex indices for the refined cells.  <br /></td></tr>
<tr class="separator:a01fb545a69963a1653356bdf274a4b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e53c7384fbc6db2ef04a4aacbb4789" id="r_a89e53c7384fbc6db2ef04a4aacbb4789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e53c7384fbc6db2ef04a4aacbb4789">refinedCellMeasures</a></td></tr>
<tr class="memdesc:a89e53c7384fbc6db2ef04a4aacbb4789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector of measures (areas) for the refined cells.  <br /></td></tr>
<tr class="separator:a89e53c7384fbc6db2ef04a4aacbb4789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58797efce612f3f69f0c480f9f9e3e1" id="r_ab58797efce612f3f69f0c480f9f9e3e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab58797efce612f3f69f0c480f9f9e3e1">originalCells</a></td></tr>
<tr class="memdesc:ab58797efce612f3f69f0c480f9f9e3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of indices of original triangles (belong to the refined triangles)  <br /></td></tr>
<tr class="separator:ab58797efce612f3f69f0c480f9f9e3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4ae046d39c7de95fedfbec9709093" id="r_abee4ae046d39c7de95fedfbec9709093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee4ae046d39c7de95fedfbec9709093">refinedCellParents</a></td></tr>
<tr class="memdesc:abee4ae046d39c7de95fedfbec9709093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of indices of direct parent cells of the refined cells.  <br /></td></tr>
<tr class="separator:abee4ae046d39c7de95fedfbec9709093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29bc725ac1f27d029965fb4537a605e" id="r_ab29bc725ac1f27d029965fb4537a605e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29bc725ac1f27d029965fb4537a605e">refinedSimpleNeighborsTasks</a></td></tr>
<tr class="memdesc:ab29bc725ac1f27d029965fb4537a605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of tasks for integration over refined simple neighbor pairs.  <br /></td></tr>
<tr class="separator:ab29bc725ac1f27d029965fb4537a605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23fc01227839e3eb59a0b1ab2ea3658" id="r_aa23fc01227839e3eb59a0b1ab2ea3658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa23fc01227839e3eb59a0b1ab2ea3658">refinedAttachedNeighborsTasks</a></td></tr>
<tr class="memdesc:aa23fc01227839e3eb59a0b1ab2ea3658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of tasks for integration over refined attached neighbor pairs.  <br /></td></tr>
<tr class="separator:aa23fc01227839e3eb59a0b1ab2ea3658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14461ed94dc3b80535c52f7e7be1267" id="r_af14461ed94dc3b80535c52f7e7be1267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14461ed94dc3b80535c52f7e7be1267">refinedNotNeighborsTasks</a></td></tr>
<tr class="memdesc:af14461ed94dc3b80535c52f7e7be1267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of tasks for integration over refined non-neighbor pairs.  <br /></td></tr>
<tr class="separator:af14461ed94dc3b80535c52f7e7be1267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab387976f65ce13ab274cb5fb649d61f8" id="r_ab387976f65ce13ab274cb5fb649d61f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab387976f65ce13ab274cb5fb649d61f8">d_simpleNeighborsResults</a></td></tr>
<tr class="memdesc:ab387976f65ce13ab274cb5fb649d61f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of integration tasks over refined simple neighbor pairs.  <br /></td></tr>
<tr class="separator:ab387976f65ce13ab274cb5fb649d61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ddf2ef9be7cfac5b54563ad76bbc6" id="r_a105ddf2ef9be7cfac5b54563ad76bbc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a105ddf2ef9be7cfac5b54563ad76bbc6">d_attachedNeighborsResults</a></td></tr>
<tr class="memdesc:a105ddf2ef9be7cfac5b54563ad76bbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of integration tasks over refined attached neighbor pairs.  <br /></td></tr>
<tr class="separator:a105ddf2ef9be7cfac5b54563ad76bbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8b5e1bd00a32a67b6d9589cc6dfd1c" id="r_abd8b5e1bd00a32a67b6d9589cc6dfd1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd8b5e1bd00a32a67b6d9589cc6dfd1c">d_notNeighborsResults</a></td></tr>
<tr class="memdesc:abd8b5e1bd00a32a67b6d9589cc6dfd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of integration tasks over refined non-neighbor pairs.  <br /></td></tr>
<tr class="separator:abd8b5e1bd00a32a67b6d9589cc6dfd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb0ee10587778046f90b10485f54b22" id="r_a0eb0ee10587778046f90b10485f54b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eb0ee10587778046f90b10485f54b22">tempRefinedSimpleNeighborsTasks</a></td></tr>
<tr class="memdesc:a0eb0ee10587778046f90b10485f54b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional buffer for tasks for integration over refined simple neighbor pairs.  <br /></td></tr>
<tr class="separator:a0eb0ee10587778046f90b10485f54b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c2d05a5e192209dbb7bc8c84c2c768" id="r_ac6c2d05a5e192209dbb7bc8c84c2c768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c2d05a5e192209dbb7bc8c84c2c768">tempRefinedAttachedNeighborsTasks</a></td></tr>
<tr class="memdesc:ac6c2d05a5e192209dbb7bc8c84c2c768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional buffer for tasks for integration over refined attached neighbor pairs.  <br /></td></tr>
<tr class="separator:ac6c2d05a5e192209dbb7bc8c84c2c768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf26efb6ab77ebed85201a68cbcff8d" id="r_aebf26efb6ab77ebed85201a68cbcff8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf26efb6ab77ebed85201a68cbcff8d">tempRefinedNotNeighborsTasks</a></td></tr>
<tr class="memdesc:aebf26efb6ab77ebed85201a68cbcff8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional buffer for tasks for integration over refined non-neighbor pairs.  <br /></td></tr>
<tr class="separator:aebf26efb6ab77ebed85201a68cbcff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755f011ad8dfc653c9e85acd4a13278" id="r_af755f011ad8dfc653c9e85acd4a13278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af755f011ad8dfc653c9e85acd4a13278">simpleNeighborsIntegralsConverged</a></td></tr>
<tr class="memdesc:af755f011ad8dfc653c9e85acd4a13278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of flags which show whether the integration of the task has already converged (for the original, non-refined simple neighbor pairs)  <br /></td></tr>
<tr class="separator:af755f011ad8dfc653c9e85acd4a13278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2e96dbeca2e044e21e5f976af46fd1" id="r_a5d2e96dbeca2e044e21e5f976af46fd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d2e96dbeca2e044e21e5f976af46fd1">attachedNeighborsIntegralsConverged</a></td></tr>
<tr class="memdesc:a5d2e96dbeca2e044e21e5f976af46fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of flags which show whether the integration of the task has already converged (for the original, non-refined attached neighbor pairs)  <br /></td></tr>
<tr class="separator:a5d2e96dbeca2e044e21e5f976af46fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb97c65e1b593e5b0b72c0e510176e15" id="r_abb97c65e1b593e5b0b72c0e510176e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb97c65e1b593e5b0b72c0e510176e15">notNeighborsIntegralsConverged</a></td></tr>
<tr class="memdesc:abb97c65e1b593e5b0b72c0e510176e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of flags which show whether the integration of the task has already converged (for the original, non-refined non-neighbor pairs)  <br /></td></tr>
<tr class="separator:abb97c65e1b593e5b0b72c0e510176e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd84161188245329330592c0c52256d1" id="r_afd84161188245329330592c0c52256d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; <a class="el" href="cuda__math_8cuh.html#a16b7f1b886fa3763a23e6ae41602aa63">Point3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd84161188245329330592c0c52256d1">tempVertices</a></td></tr>
<tr class="memdesc:afd84161188245329330592c0c52256d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer for coordinates of refined mesh vertices.  <br /></td></tr>
<tr class="separator:afd84161188245329330592c0c52256d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d75cf6b62430fd5d67c1568fff04b" id="r_aed1d75cf6b62430fd5d67c1568fff04b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed1d75cf6b62430fd5d67c1568fff04b">tempCells</a></td></tr>
<tr class="memdesc:aed1d75cf6b62430fd5d67c1568fff04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer for vertex indices of refined mesh cells.  <br /></td></tr>
<tr class="separator:aed1d75cf6b62430fd5d67c1568fff04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6fd50d61c58aec2ed171c12d5d41dd" id="r_a4b6fd50d61c58aec2ed171c12d5d41dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b6fd50d61c58aec2ed171c12d5d41dd">tempCellMeasures</a></td></tr>
<tr class="memdesc:a4b6fd50d61c58aec2ed171c12d5d41dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer for vector of measures (areas) of refined cells.  <br /></td></tr>
<tr class="separator:a4b6fd50d61c58aec2ed171c12d5d41dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46af40f748281ff69c53c8a6fd969b0" id="r_aa46af40f748281ff69c53c8a6fd969b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46af40f748281ff69c53c8a6fd969b0">tempOriginalCells</a></td></tr>
<tr class="memdesc:aa46af40f748281ff69c53c8a6fd969b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary buffer for vector of indices of original triangles for refined cells.  <br /></td></tr>
<tr class="separator:aa46af40f748281ff69c53c8a6fd969b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ae6c1f6bb8b21d0b27b7d418dbe92" id="r_ae58ae6c1f6bb8b21d0b27b7d418dbe92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae58ae6c1f6bb8b21d0b27b7d418dbe92">cellsToBeRefined</a></td></tr>
<tr class="memdesc:ae58ae6c1f6bb8b21d0b27b7d418dbe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of indices of cells which need to be refined for further calculation of integrals over them.  <br /></td></tr>
<tr class="separator:ae58ae6c1f6bb8b21d0b27b7d418dbe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bb22f74f8975620d6b492b13bebbc" id="r_aef0bb22f74f8975620d6b492b13bebbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0bb22f74f8975620d6b492b13bebbc">cellRequiresRefinement</a></td></tr>
<tr class="memdesc:aef0bb22f74f8975620d6b492b13bebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate vector of flags indicating that a cell (from the original list) requires refinement.  <br /></td></tr>
<tr class="separator:aef0bb22f74f8975620d6b492b13bebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af138d12584ddae680b8a5921804c5340" id="r_af138d12584ddae680b8a5921804c5340"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af138d12584ddae680b8a5921804c5340">d_cellsToBeRefinedCount</a> = nullptr</td></tr>
<tr class="memdesc:af138d12584ddae680b8a5921804c5340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device counter of a number of cells which need to be refined.  <br /></td></tr>
<tr class="separator:af138d12584ddae680b8a5921804c5340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474e90cb8ef74a8ae8a2548f7e768c2" id="r_a9474e90cb8ef74a8ae8a2548f7e768c2"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9474e90cb8ef74a8ae8a2548f7e768c2">taskCount</a> = nullptr</td></tr>
<tr class="memdesc:a9474e90cb8ef74a8ae8a2548f7e768c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device counter of a number of refined tasks.  <br /></td></tr>
<tr class="separator:a9474e90cb8ef74a8ae8a2548f7e768c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e6af8bd83c6957a47fed5993aa3b2d" id="r_ac6e6af8bd83c6957a47fed5993aa3b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_numerical_integrator3d_8cuh.html#a9ab58cb389e76d256ba909cefae8d806">error_control_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e6af8bd83c6957a47fed5993aa3b2d">errorControlType</a></td></tr>
<tr class="memdesc:ac6e6af8bd83c6957a47fed5993aa3b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specified mode of error control.  <br /></td></tr>
<tr class="separator:ac6e6af8bd83c6957a47fed5993aa3b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869655694891a0a703bfbcbf6b6d82c" id="r_af869655694891a0a703bfbcbf6b6d82c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af869655694891a0a703bfbcbf6b6d82c">meshRefinementLevel</a></td></tr>
<tr class="memdesc:af869655694891a0a703bfbcbf6b6d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specified level of mesh refinement.  <br /></td></tr>
<tr class="separator:af869655694891a0a703bfbcbf6b6d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a68d0a08f974fedb3bf9acde1066c4" id="r_a50a68d0a08f974fedb3bf9acde1066c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a68d0a08f974fedb3bf9acde1066c4">simpleNeighborsRefinementsRequired</a></td></tr>
<tr class="memdesc:a50a68d0a08f974fedb3bf9acde1066c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector with number of required refinements for each cell when integrating over simple neighbor pairs.  <br /></td></tr>
<tr class="separator:a50a68d0a08f974fedb3bf9acde1066c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd0d89837697743995206cba8d26610" id="r_abcd0d89837697743995206cba8d26610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd0d89837697743995206cba8d26610">attachedNeighborsRefinementsRequired</a></td></tr>
<tr class="memdesc:abcd0d89837697743995206cba8d26610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector with number of required refinements for each cell when integrating over attached neighbor pairs.  <br /></td></tr>
<tr class="separator:abcd0d89837697743995206cba8d26610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220f546abf4166066b36e742f9c56f48" id="r_a220f546abf4166066b36e742f9c56f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220f546abf4166066b36e742f9c56f48">notNeighborsRefinementsRequired</a></td></tr>
<tr class="memdesc:a220f546abf4166066b36e742f9c56f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector with number of required refinements for each cell when integrating over non-neighbor pairs.  <br /></td></tr>
<tr class="separator:a220f546abf4166066b36e742f9c56f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class responsible for the whole numerical integration procedure. </p>
<p>The class is responsible for</p><ul>
<li>numerical integration itself, using Gaussian quadrature rules;</li>
<li>forming the list of cells that require refinement;</li>
<li>mesh refinement and creation of new tasks for the refined cells;</li>
<li>gathering of results of integration over refined cells into original integral values.</li>
</ul>
<p>Two modes are available:</p><ol type="1">
<li>Fixed level of refinement for the whole mesh (can also be zero) - memory- and time-consuming;</li>
<li>Automatic error control using the Runge rule. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6beece1578d8737b31db031f46a258c8" name="a6beece1578d8737b31db031f46a258c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beece1578d8737b31db031f46a258c8">&#9670;&#160;</a></span>NumericalIntegrator3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NumericalIntegrator3D::NumericalIntegrator3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mesh3_d.html">Mesh3D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_quadrature_formula3_d.html">QuadratureFormula3D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qf_</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_numerical_integrator3_d.html" title="Class responsible for the whole numerical integration procedure.">NumericalIntegrator3D</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_</td><td>Existing <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object </td></tr>
    <tr><td class="paramname">qf_</td><td>Quadrature formula</td></tr>
  </table>
  </dd>
</dl>
<p>Vector of L-coordinates for Gaussian points is filled (initially the quadrature formula does not store the last coordinate) and copied to the device constant memory together with weights of the Gaussian points and their number.</p>
<p>Error control mode is set to automatic error control by default. </p>

</div>
</div>
<a id="a528ef4eaa86844a2cdaaca811e430be9" name="a528ef4eaa86844a2cdaaca811e430be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528ef4eaa86844a2cdaaca811e430be9">&#9670;&#160;</a></span>~NumericalIntegrator3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumericalIntegrator3D::~NumericalIntegrator3D </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="class_numerical_integrator3_d.html" title="Class responsible for the whole numerical integration procedure.">NumericalIntegrator3D</a> object. </p>
<p>Deallocate memory for counters of tasks, refined vertices and cells, cells requiring refinement. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9bdb368b126eb637bfcf71ea970a962" name="af9bdb368b126eb637bfcf71ea970a962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bdb368b126eb637bfcf71ea970a962">&#9670;&#160;</a></span>determineCellsToBeRefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NumericalIntegrator3D::determineCellsToBeRefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>restTasks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; *</td>          <td class="paramname"><span class="paramname"><em>tasks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the list of indices of cells which require further refinement, using the list of integrals which have not converged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restTasks</td><td>Indices of integration tasks which have not yet converged </td></tr>
    <tr><td class="paramname">tasks</td><td>List of all integration task on current iteration </td></tr>
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of cells which require refinement</dd></dl>
<p>The following kernels are called:</p><ol type="1">
<li>Setting to 'true' the flag of cells which are control panels of at least one integration task which has not converged.</li>
<li>Extracting indices of the flags set to 'true'.</li>
<li>Increasing the number of required requirements for these cells by 1 (used for output to VTK). </li>
</ol>

</div>
</div>
<a id="a22fe152d3e7a9ad1de95857f5191b29d" name="a22fe152d3e7a9ad1de95857f5191b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fe152d3e7a9ad1de95857f5191b29d">&#9670;&#160;</a></span>gatherResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NumericalIntegrator3D::gatherResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum up the results of integration over refined cells (for a specific type of neighbors) into the vector for original task results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>Target vector for integration results for original tasks </td></tr>
    <tr><td class="paramname">neighborType</td><td>Type of neighbors</td></tr>
  </table>
  </dd>
</dl>
<p>Both input and output results contain separate values for \(\mathbf{\Psi}\) and \(\Theta\). A kernel function is called which performs summation using atomicAdd and the index of the original task for each refined one. </p>

</div>
</div>
<a id="a5be924a775975731f2bc587a5da4459c" name="a5be924a775975731f2bc587a5da4459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be924a775975731f2bc587a5da4459c">&#9670;&#160;</a></span>getCellsToBeRefined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; NumericalIntegrator3D::getCellsToBeRefined </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of indices of cells which are to be refined. </p>
<dl class="section return"><dt>Returns</dt><dd>auto&amp; Device vector of indices (in the whole current list of cells) of cells which are to be refined </dd></dl>

</div>
</div>
<a id="a6569bfcf131ae540cf3c434ab8455da1" name="a6569bfcf131ae540cf3c434ab8455da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6569bfcf131ae540cf3c434ab8455da1">&#9670;&#160;</a></span>getErrorControlType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_numerical_integrator3d_8cuh.html#a9ab58cb389e76d256ba909cefae8d806">error_control_type_enum</a> NumericalIntegrator3D::getErrorControlType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of error control. </p>
<dl class="section return"><dt>Returns</dt><dd>error_control_type_enum Current type of error control mode </dd></dl>

</div>
</div>
<a id="a2bc832bfc967e32f463dc8cebdf14404" name="a2bc832bfc967e32f463dc8cebdf14404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc832bfc967e32f463dc8cebdf14404">&#9670;&#160;</a></span>getGaussPointsNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumericalIntegrator3D::getGaussPointsNumber </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Gauss Points. </p>
<dl class="section return"><dt>Returns</dt><dd>int Number of Gauss points</dd></dl>
<p>Used for passing the number of Gaussian points to kernel functions </p>

</div>
</div>
<a id="a242109ec3a41e2d36705b8502f32ac7c" name="a242109ec3a41e2d36705b8502f32ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242109ec3a41e2d36705b8502f32ac7c">&#9670;&#160;</a></span>getIntegralsConverged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt; * NumericalIntegrator3D::getIntegralsConverged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of flags which show whether the integration of the task has already converged (for a specific type of neighbor cells) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="structdevice_vector.html">deviceVector&lt;unsigned char&gt;</a>* Pointer to device vector of flags for convergence of integration tasks</dd></dl>
<p>The values of flags are either 'true' or 'false'. Flags are assigned during the procedure of comparing integration results between the current and previous iterations. Later new tasks are created only for the original tasks whose flag is still 'false'. </p>

</div>
</div>
<a id="ad59c7d39fabdc91179608d50926e9d3d" name="ad59c7d39fabdc91179608d50926e9d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59c7d39fabdc91179608d50926e9d3d">&#9670;&#160;</a></span>getQuadratureFormulaOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumericalIntegrator3D::getQuadratureFormulaOrder </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the order of the specified quadrature formula. </p>
<dl class="section return"><dt>Returns</dt><dd>int Order of the selected quarature formula </dd></dl>

</div>
</div>
<a id="a75e7e86b9399d3c88decf212101ed473" name="a75e7e86b9399d3c88decf212101ed473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e7e86b9399d3c88decf212101ed473">&#9670;&#160;</a></span>getRefinedCellMeasures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; NumericalIntegrator3D::getRefinedCellMeasures </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of measures (areas) of refined cells. </p>
<dl class="section return"><dt>Returns</dt><dd>const auto&amp; Device vector of measures (areas) for the refined cells</dd></dl>
<p>The vector is used for passing as an argument to kernel functions.</p>
<p>The values for cells may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and measures for new cells are added) </p>

</div>
</div>
<a id="a732baba2145a1bb794a104a19704a09e" name="a732baba2145a1bb794a104a19704a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732baba2145a1bb794a104a19704a09e">&#9670;&#160;</a></span>getRefinedCells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; NumericalIntegrator3D::getRefinedCells </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of refined cells. </p>
<dl class="section return"><dt>Returns</dt><dd>const auto&amp; Device vector of vertex indices for the refined cells</dd></dl>
<p>The vector is used for passing as an argument to kernel functions and for export to VTK. The list is filled from the beginning on each refinement iteration and does not contain cells from the previous iteration.</p>
<p>The cells may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and new cells for them are added) </p>

</div>
</div>
<a id="aa4a5601c741c6f0f9ef489201cb4e52b" name="aa4a5601c741c6f0f9ef489201cb4e52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a5601c741c6f0f9ef489201cb4e52b">&#9670;&#160;</a></span>getRefinedTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; * NumericalIntegrator3D::getRefinedTasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of integration tasks for refined cells (for a specific type of neighbor cells) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="structdevice_vector.html">deviceVector&lt;int3&gt;</a>* Pointer to device vector of tasks </dd></dl>

</div>
</div>
<a id="a62d40cf4a60a8f2a42902ea13c99e33a" name="a62d40cf4a60a8f2a42902ea13c99e33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d40cf4a60a8f2a42902ea13c99e33a">&#9670;&#160;</a></span>getRefinedVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; NumericalIntegrator3D::getRefinedVertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of refined vertices. </p>
<dl class="section return"><dt>Returns</dt><dd>const auto&amp; Device vector of coordinates of refined vertices</dd></dl>
<p>The vector is used for passing as an argument to kernel functions and for export to VTK. The list contains vertices from the previous refinement iteration after which new vertices are added.</p>
<p>The vertices may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and their vertices are added) </p>

</div>
</div>
<a id="a1f91fd30d521e4a3b95441c67dd9b0c1" name="a1f91fd30d521e4a3b95441c67dd9b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f91fd30d521e4a3b95441c67dd9b0c1">&#9670;&#160;</a></span>getRefinementsRequired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt; unsigned char &gt; * NumericalIntegrator3D::getRefinementsRequired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector with number of required refinements for each cell (for a specific type of neighbor cells) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="structdevice_vector.html">deviceVector&lt;unsigned char&gt;</a>* Pointer to device vector with number of required refinements for each cell</dd></dl>
<p>Data of this vector is used for output to the VTK file. Unsigned char data type is used due to the number of refinements being usually not higher than 10. </p>

</div>
</div>
<a id="ac3ddb7fea8012d8e4442a66bbc4e9d86" name="ac3ddb7fea8012d8e4442a66bbc4e9d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ddb7fea8012d8e4442a66bbc4e9d86">&#9670;&#160;</a></span>getResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; double4 &gt; * NumericalIntegrator3D::getResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector of results of integration for refined cells (for a specific type of neighbor cells) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="structdevice_vector.html">deviceVector&lt;double4&gt;</a>* Pointer to device vector of integration results</dd></dl>
<p>Elements of this vector are later summed up in order to fill the vector of integral values for original integration tasks </p>

</div>
</div>
<a id="aa8c6dd14524a04964910b70612b1caff" name="aa8c6dd14524a04964910b70612b1caff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c6dd14524a04964910b70612b1caff">&#9670;&#160;</a></span>prepareTasksAndMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NumericalIntegrator3D::prepareTasksAndMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>simpleNeighborsTasks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>attachedNeighborsTasks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>notNeighborsTasks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Necessary preparations (mesh and tasks) before integral calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simpleNeighborsTasks</td><td>Device vector of integration tasks for simple neighbor cell pairs </td></tr>
    <tr><td class="paramname">attachedNeighborsTasks</td><td>Device vector of integration tasks for attached neighbor cell pairs </td></tr>
    <tr><td class="paramname">notNeighborsTasks</td><td>Device vector of integration tasks for non-neighbor cell pairs</td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>Memory allocation for the refined mesh is performed ( \(v_0 \text{ and } t_0\) are the numbers of vertices and cells in the original mesh, \(n\) is the mesh refinement level - maximum value is used in case of adaptive error control):<ul>
<li>number of vertices is set to \( v_0 + t_0 (4^n - 1) \);</li>
<li>numbers of cells and cell measures are set to \( t_0\cdot 4^n \);</li>
<li>indices pointing to the cells of original mesh (the size is equal to the size of vector of refined cells).</li>
</ul>
</li>
<li>Original mesh is copied into the allocated data structures.</li>
<li>For each type of neighbor pairs memory is allocated for the refined integration tasks, integration results and (in case of adaptive error control) flags for integration procedure convergence (according to the Runge rule) and buffer for tasks.</li>
<li>In case of fixed refinement level (1 or more) mesh is refined and after that tasks are created for the refined cells. </li>
</ol>

</div>
</div>
<a id="af1960a91f376ae611a204003b1e25708" name="af1960a91f376ae611a204003b1e25708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1960a91f376ae611a204003b1e25708">&#9670;&#160;</a></span>refineMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NumericalIntegrator3D::refineMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>updateTasksNeighborType</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfda5e543256c480ac577d30f76f9120eb74">neighbour_type_enum::undefined</a></span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh refinement (whole mesh or specific cells) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateTasksNeighborType</td><td>Type of neighbors (may be undefined)</td></tr>
  </table>
  </dd>
</dl>
<p>The function swaps buffers for vertices, cells, cell measures and indices of original cells for the refined ones, and then call a kernel function which splits the whole mesh or only selected cells. Depending on the error control mode:</p><ol type="1">
<li>Fixed refinement level: the function is called required number of times before the start of the calculation. Creation of refined tasks is not called from here (as it is called in the mesh preparation procedure - once after all iterations of mesh refinement).</li>
<li>Adaptive error control: the function is called after each integral calculation iteration for the selected set of cells (after 1 iteration - the whole mesh). Swap of buffer for refined tasks and update of tasks is performed after cells have been refined </li>
</ol>

</div>
</div>
<a id="a9e6654d6637c0861803f971f1d148f3a" name="a9e6654d6637c0861803f971f1d148f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6654d6637c0861803f971f1d148f3a">&#9670;&#160;</a></span>resetMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NumericalIntegrator3D::resetMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-initialization of mesh data using the original mesh in <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object. </p>
<p>Mesh vertices, cells and measures are copied from the <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object, number of refined vertices and cells is reset using the original numbers of vertices and cells.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used for the purpose of resetting before start of calculation for another type of neighbors (the refined mesh vectors may contained fragmented mesh data from the previous integration step). </dd></dl>

</div>
</div>
<a id="a3ece2676a79cd5aa447a292aafe50cb9" name="a3ece2676a79cd5aa447a292aafe50cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ece2676a79cd5aa447a292aafe50cb9">&#9670;&#160;</a></span>setFixedRefinementLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NumericalIntegrator3D::setFixedRefinementLevel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>refinementLevel</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the fixed refinement level for the whole mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refinementLevel</td><td>Specified mesh refinement level</td></tr>
  </table>
  </dd>
</dl>
<p>Error control method is switched to fixed refinement level (default is automatic error control using the Runge rule) </p>

</div>
</div>
<a id="ac3e035ac81e89a77573f011b845d9fd8" name="ac3e035ac81e89a77573f011b845d9fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e035ac81e89a77573f011b845d9fd8">&#9670;&#160;</a></span>updateTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumericalIntegrator3D::updateTasks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdevice_vector.html">deviceVector</a>&lt; int3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>originalTasks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_mesh3d_8cuh.html#a455d6c342e2f2268444f366ebc59abfd">neighbour_type_enum</a></td>          <td class="paramname"><span class="paramname"><em>neighborType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new integration tasks for the refined cells, based on the the existing list of tasks for parent cells <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTasks</td><td>Vector of tasks to be used to create new tasks for refined cells </td></tr>
    <tr><td class="paramname">neighborType</td><td>Type of neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int New number of tasks (for the refined cells)</dd></dl>
<p>Two (almost) identical calls of a kernel function are performed. First is needed to count the number of tasks to be created. During the second run the tasks are actually created.</p>
<p>Situation is a bit different depending on the error control mode:</p><ul>
<li>in case of fixed mesh refinement level tasks creation is perfomed only after the mesh has been refined the desired number of times. Then the memory for refined tasks is allocated and new tasks are created based on the original ones;</li>
<li>in case of adaptive mesh control tasks are created after every integration procedure. In this case vectors of refined integration tasks and results are resized accordingly and new tasks are created using the tasks from the previous iteration. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5d2e96dbeca2e044e21e5f976af46fd1" name="a5d2e96dbeca2e044e21e5f976af46fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2e96dbeca2e044e21e5f976af46fd1">&#9670;&#160;</a></span>attachedNeighborsIntegralsConverged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::attachedNeighborsIntegralsConverged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of flags which show whether the integration of the task has already converged (for the original, non-refined attached neighbor pairs) </p>
<p>The values of flags are either 'true' or 'false'. Flags are assigned during the procedure of comparing integration results between the current and previous iterations. Later new tasks are created only for the original tasks whose flag is still 'false'. </p>

</div>
</div>
<a id="abcd0d89837697743995206cba8d26610" name="abcd0d89837697743995206cba8d26610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd0d89837697743995206cba8d26610">&#9670;&#160;</a></span>attachedNeighborsRefinementsRequired</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::attachedNeighborsRefinementsRequired</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector with number of required refinements for each cell when integrating over attached neighbor pairs. </p>
<p>The cell is consider to be \(i\)-th cell in pair \((i,j)\) (control panel). Unsigned char data type is used due to the number of refinements being usually not higher than 10. </p>

</div>
</div>
<a id="aef0bb22f74f8975620d6b492b13bebbc" name="aef0bb22f74f8975620d6b492b13bebbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0bb22f74f8975620d6b492b13bebbc">&#9670;&#160;</a></span>cellRequiresRefinement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::cellRequiresRefinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intermediate vector of flags indicating that a cell (from the original list) requires refinement. </p>
<p>The values are obtained by analyzing the list of tasks which are still left for integration, the next kernel function extracts indices of such cells, which are then refined </p>

</div>
</div>
<a id="ae58ae6c1f6bb8b21d0b27b7d418dbe92" name="ae58ae6c1f6bb8b21d0b27b7d418dbe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58ae6c1f6bb8b21d0b27b7d418dbe92">&#9670;&#160;</a></span>cellsToBeRefined</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int&gt; NumericalIntegrator3D::cellsToBeRefined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of indices of cells which need to be refined for further calculation of integrals over them. </p>
<p>Indices point to positions in the list of refined cells </p>

</div>
</div>
<a id="a105ddf2ef9be7cfac5b54563ad76bbc6" name="a105ddf2ef9be7cfac5b54563ad76bbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105ddf2ef9be7cfac5b54563ad76bbc6">&#9670;&#160;</a></span>d_attachedNeighborsResults</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;double4&gt; NumericalIntegrator3D::d_attachedNeighborsResults</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Results of integration tasks over refined attached neighbor pairs. </p>
<p>Values in this list are later summed up in order to obtain values of integrals for original tasks (using indices for correspondence of original and refined tasks). Each entry stores separately values for \(\mathbf{\Psi}\) and \(\Theta\) </p>

</div>
</div>
<a id="af138d12584ddae680b8a5921804c5340" name="af138d12584ddae680b8a5921804c5340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af138d12584ddae680b8a5921804c5340">&#9670;&#160;</a></span>d_cellsToBeRefinedCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* NumericalIntegrator3D::d_cellsToBeRefinedCount = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device counter of a number of cells which need to be refined. </p>

</div>
</div>
<a id="abd8b5e1bd00a32a67b6d9589cc6dfd1c" name="abd8b5e1bd00a32a67b6d9589cc6dfd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8b5e1bd00a32a67b6d9589cc6dfd1c">&#9670;&#160;</a></span>d_notNeighborsResults</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;double4&gt; NumericalIntegrator3D::d_notNeighborsResults</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Results of integration tasks over refined non-neighbor pairs. </p>
<p>Values in this list are later summed up in order to obtain values of integrals for original tasks (using indices for correspondence of original and refined tasks). Each entry stores separately values for \(\mathbf{\Psi}\) and \(\Theta\) </p>

</div>
</div>
<a id="ab387976f65ce13ab274cb5fb649d61f8" name="ab387976f65ce13ab274cb5fb649d61f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab387976f65ce13ab274cb5fb649d61f8">&#9670;&#160;</a></span>d_simpleNeighborsResults</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;double4&gt; NumericalIntegrator3D::d_simpleNeighborsResults</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Results of integration tasks over refined simple neighbor pairs. </p>
<p>Values in this list are later summed up in order to obtain values of integrals for original tasks (using indices for correspondence of original and refined tasks). Each entry stores separately values for \(\mathbf{\Psi}\) and \(\Theta\) </p>

</div>
</div>
<a id="ac6e6af8bd83c6957a47fed5993aa3b2d" name="ac6e6af8bd83c6957a47fed5993aa3b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e6af8bd83c6957a47fed5993aa3b2d">&#9670;&#160;</a></span>errorControlType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_numerical_integrator3d_8cuh.html#a9ab58cb389e76d256ba909cefae8d806">error_control_type_enum</a> NumericalIntegrator3D::errorControlType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specified mode of error control. </p>
<p>Default value is automatic error control procedure using the Runge rule </p>

</div>
</div>
<a id="a8235749e20de0d7f64cbab82868f7e52" name="a8235749e20de0d7f64cbab82868f7e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8235749e20de0d7f64cbab82868f7e52">&#9670;&#160;</a></span>GaussPointsNum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int NumericalIntegrator3D::GaussPointsNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of Gaussian points in the quadrature formula. </p>

</div>
</div>
<a id="a8fd6c1af3c33516e17a55b11e3e479fa" name="a8fd6c1af3c33516e17a55b11e3e479fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd6c1af3c33516e17a55b11e3e479fa">&#9670;&#160;</a></span>mesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_mesh3_d.html">Mesh3D</a>&amp; NumericalIntegrator3D::mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="class_mesh3_d.html" title="Class for storage of mesh information.">Mesh3D</a> object with the original surface mesh. </p>
<p>Vertices, cells and measures are used from the original mesh </p>

</div>
</div>
<a id="af869655694891a0a703bfbcbf6b6d82c" name="af869655694891a0a703bfbcbf6b6d82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af869655694891a0a703bfbcbf6b6d82c">&#9670;&#160;</a></span>meshRefinementLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumericalIntegrator3D::meshRefinementLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specified level of mesh refinement. </p>
<p>The value is only used if the mode of full mesh refinement is selected. Mesh refinement level can be set to 0, then integrals are calculated on the original mesh. </p>

</div>
</div>
<a id="abb97c65e1b593e5b0b72c0e510176e15" name="abb97c65e1b593e5b0b72c0e510176e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb97c65e1b593e5b0b72c0e510176e15">&#9670;&#160;</a></span>notNeighborsIntegralsConverged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::notNeighborsIntegralsConverged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of flags which show whether the integration of the task has already converged (for the original, non-refined non-neighbor pairs) </p>
<p>The values of flags are either 'true' or 'false'. Flags are assigned during the procedure of comparing integration results between the current and previous iterations. Later new tasks are created only for the original tasks whose flag is still 'false'. </p>

</div>
</div>
<a id="a220f546abf4166066b36e742f9c56f48" name="a220f546abf4166066b36e742f9c56f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220f546abf4166066b36e742f9c56f48">&#9670;&#160;</a></span>notNeighborsRefinementsRequired</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::notNeighborsRefinementsRequired</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector with number of required refinements for each cell when integrating over non-neighbor pairs. </p>
<p>The cell is consider to be \(i\)-th cell in pair \((i,j)\) (control panel). Unsigned char data type is used due to the number of refinements being usually not higher than 10. </p>

</div>
</div>
<a id="ab58797efce612f3f69f0c480f9f9e3e1" name="ab58797efce612f3f69f0c480f9f9e3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58797efce612f3f69f0c480f9f9e3e1">&#9670;&#160;</a></span>originalCells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int&gt; NumericalIntegrator3D::originalCells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of indices of original triangles (belong to the refined triangles) </p>
<p>The index points to a cell in the original mesh.</p>
<p>Initially the list is filled with \(0,1,\ldots,n-1\), and later during the refinements the index is handed over from parent triangle to child ones without any changes. </p>

</div>
</div>
<a id="a0ae8cdb315882b26d2cd46db41d55011" name="a0ae8cdb315882b26d2cd46db41d55011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae8cdb315882b26d2cd46db41d55011">&#9670;&#160;</a></span>qf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_quadrature_formula3_d.html">QuadratureFormula3D</a>&amp; NumericalIntegrator3D::qf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A quadrature formula selected for numerical integration. </p>
<p>Data from the quadrature formula (which is a static object) is copied to the device constant memory </p>

</div>
</div>
<a id="aa23fc01227839e3eb59a0b1ab2ea3658" name="aa23fc01227839e3eb59a0b1ab2ea3658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23fc01227839e3eb59a0b1ab2ea3658">&#9670;&#160;</a></span>refinedAttachedNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::refinedAttachedNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of tasks for integration over refined attached neighbor pairs. </p>
<p>The tasks has the form \((i,j,k)\) where \(i,j\) correspond to the indices of refined cells and \(k\) is the index of original non-refined task. The vector of tasks is obtained from the previous vector tasks (original tasks or already refined list) after cells are refined </p>

</div>
</div>
<a id="a89e53c7384fbc6db2ef04a4aacbb4789" name="a89e53c7384fbc6db2ef04a4aacbb4789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e53c7384fbc6db2ef04a4aacbb4789">&#9670;&#160;</a></span>refinedCellMeasures</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;double&gt; NumericalIntegrator3D::refinedCellMeasures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device vector of measures (areas) for the refined cells. </p>
<p>The values for cells may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and measures for new cells are added) </p>

</div>
</div>
<a id="abee4ae046d39c7de95fedfbec9709093" name="abee4ae046d39c7de95fedfbec9709093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee4ae046d39c7de95fedfbec9709093">&#9670;&#160;</a></span>refinedCellParents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int&gt; NumericalIntegrator3D::refinedCellParents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of indices of direct parent cells of the refined cells. </p>
<p>The index points to a cell in the list for the previous iteration.</p>
<p>The values are used in the procedure of task creation after mesh refinement in order to decide whether a new task should be created for an old one or not. </p>

</div>
</div>
<a id="a01fb545a69963a1653356bdf274a4b1e" name="a01fb545a69963a1653356bdf274a4b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fb545a69963a1653356bdf274a4b1e">&#9670;&#160;</a></span>refinedCells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::refinedCells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device vector of vertex indices for the refined cells. </p>
<p>The cells may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and new cells for them are added) </p>

</div>
</div>
<a id="af14461ed94dc3b80535c52f7e7be1267" name="af14461ed94dc3b80535c52f7e7be1267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14461ed94dc3b80535c52f7e7be1267">&#9670;&#160;</a></span>refinedNotNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::refinedNotNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of tasks for integration over refined non-neighbor pairs. </p>
<p>The tasks has the form \((i,j,k)\) where \(i,j\) correspond to the indices of refined cells and \(k\) is the index of original non-refined task. The vector of tasks is obtained from the previous vector tasks (original tasks or already refined list) after cells are refined </p>

</div>
</div>
<a id="ab29bc725ac1f27d029965fb4537a605e" name="ab29bc725ac1f27d029965fb4537a605e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29bc725ac1f27d029965fb4537a605e">&#9670;&#160;</a></span>refinedSimpleNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::refinedSimpleNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of tasks for integration over refined simple neighbor pairs. </p>
<p>The tasks has the form \((i,j,k)\) where \(i,j\) correspond to the indices of refined cells and \(k\) is the index of original non-refined task. The vector of tasks is obtained from the previous vector tasks (original tasks or already refined list) after cells are refined </p>

</div>
</div>
<a id="ab706eea15d5ee8eadebf211d122b4723" name="ab706eea15d5ee8eadebf211d122b4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab706eea15d5ee8eadebf211d122b4723">&#9670;&#160;</a></span>refinedVertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;<a class="el" href="cuda__math_8cuh.html#a16b7f1b886fa3763a23e6ae41602aa63">Point3</a>&gt; NumericalIntegrator3D::refinedVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device vector of coordinates of refined vertices. </p>
<p>The vertices may not cover the whole mesh if adaptive mesh refinement procedure is used (only specific cells are refined and their vertices are added) </p>

</div>
</div>
<a id="ade540c948ce982e88f24b5716828a4a1" name="ade540c948ce982e88f24b5716828a4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade540c948ce982e88f24b5716828a4a1">&#9670;&#160;</a></span>refinedVerticesCellsNum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int2* NumericalIntegrator3D::refinedVerticesCellsNum = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current numbers of vertices and cells in the refined mesh stored on the device. </p>
<p>The value is initialized by the value in the host memory, then it is updated in the mesh refinement procedure. 2 numbers are stored as 1 int2 value (.x refers to vertices, .y - to cells) </p>

</div>
</div>
<a id="af755f011ad8dfc653c9e85acd4a13278" name="af755f011ad8dfc653c9e85acd4a13278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755f011ad8dfc653c9e85acd4a13278">&#9670;&#160;</a></span>simpleNeighborsIntegralsConverged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::simpleNeighborsIntegralsConverged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of flags which show whether the integration of the task has already converged (for the original, non-refined simple neighbor pairs) </p>
<p>The values of flags are either 'true' or 'false'. Flags are assigned during the procedure of comparing integration results between the current and previous iterations. Later new tasks are created only for the original tasks whose flag is still 'false'. </p>

</div>
</div>
<a id="a50a68d0a08f974fedb3bf9acde1066c4" name="a50a68d0a08f974fedb3bf9acde1066c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a68d0a08f974fedb3bf9acde1066c4">&#9670;&#160;</a></span>simpleNeighborsRefinementsRequired</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;unsigned char&gt; NumericalIntegrator3D::simpleNeighborsRefinementsRequired</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector with number of required refinements for each cell when integrating over simple neighbor pairs. </p>
<p>The cell is consider to be \(i\)-th cell in pair \((i,j)\) (control panel). Unsigned char data type is used due to the number of refinements being usually not higher than 10. </p>

</div>
</div>
<a id="a9474e90cb8ef74a8ae8a2548f7e768c2" name="a9474e90cb8ef74a8ae8a2548f7e768c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474e90cb8ef74a8ae8a2548f7e768c2">&#9670;&#160;</a></span>taskCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* NumericalIntegrator3D::taskCount = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device counter of a number of refined tasks. </p>
<p>The value is accumulated during execution of a kernel function while analyzes the existing tasks and refined cells. The value serves the purpose of determining the size (and allocating/re-allocating memory if necessary) for vectors of refined tasks and integration results. </p>

</div>
</div>
<a id="a4b6fd50d61c58aec2ed171c12d5d41dd" name="a4b6fd50d61c58aec2ed171c12d5d41dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6fd50d61c58aec2ed171c12d5d41dd">&#9670;&#160;</a></span>tempCellMeasures</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;double&gt; NumericalIntegrator3D::tempCellMeasures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary buffer for vector of measures (areas) of refined cells. </p>
<p>The vector is used during the refinement procedure in case of fixed mesh refinement level, or is swapped alternatively with the main vector of vector of measures (areas) of refined cells in case of adaptive error control procedure </p>

</div>
</div>
<a id="aed1d75cf6b62430fd5d67c1568fff04b" name="aed1d75cf6b62430fd5d67c1568fff04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1d75cf6b62430fd5d67c1568fff04b">&#9670;&#160;</a></span>tempCells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::tempCells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary buffer for vertex indices of refined mesh cells. </p>
<p>The vector is used during the refinement procedure in case of fixed mesh refinement level, or is swapped alternatively with the main vector of vertex indices of refined mesh cells in case of adaptive error control procedure </p>

</div>
</div>
<a id="aa46af40f748281ff69c53c8a6fd969b0" name="aa46af40f748281ff69c53c8a6fd969b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46af40f748281ff69c53c8a6fd969b0">&#9670;&#160;</a></span>tempOriginalCells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int&gt; NumericalIntegrator3D::tempOriginalCells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary buffer for vector of indices of original triangles for refined cells. </p>
<p>The vector is used during the refinement procedure in case of fixed mesh refinement level, or is swapped alternatively with the main vector of vector of indices of original triangles for refined cells in case of adaptive error control procedure </p>

</div>
</div>
<a id="ac6c2d05a5e192209dbb7bc8c84c2c768" name="ac6c2d05a5e192209dbb7bc8c84c2c768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c2d05a5e192209dbb7bc8c84c2c768">&#9670;&#160;</a></span>tempRefinedAttachedNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::tempRefinedAttachedNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional buffer for tasks for integration over refined attached neighbor pairs. </p>
<p>Used in case of adaptive error control procedure, this buffer is swapped with the main list of refined tasks alternatively, at each integration iteration. </p>

</div>
</div>
<a id="aebf26efb6ab77ebed85201a68cbcff8d" name="aebf26efb6ab77ebed85201a68cbcff8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf26efb6ab77ebed85201a68cbcff8d">&#9670;&#160;</a></span>tempRefinedNotNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::tempRefinedNotNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional buffer for tasks for integration over refined non-neighbor pairs. </p>
<p>Used in case of adaptive error control procedure, this buffer is swapped with the main list of refined tasks alternatively, at each integration iteration. </p>

</div>
</div>
<a id="a0eb0ee10587778046f90b10485f54b22" name="a0eb0ee10587778046f90b10485f54b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb0ee10587778046f90b10485f54b22">&#9670;&#160;</a></span>tempRefinedSimpleNeighborsTasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;int3&gt; NumericalIntegrator3D::tempRefinedSimpleNeighborsTasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional buffer for tasks for integration over refined simple neighbor pairs. </p>
<p>Used in case of adaptive error control procedure, this buffer is swapped with the main list of refined tasks alternatively, at each integration iteration. </p>

</div>
</div>
<a id="afd84161188245329330592c0c52256d1" name="afd84161188245329330592c0c52256d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd84161188245329330592c0c52256d1">&#9670;&#160;</a></span>tempVertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdevice_vector.html">deviceVector</a>&lt;<a class="el" href="cuda__math_8cuh.html#a16b7f1b886fa3763a23e6ae41602aa63">Point3</a>&gt; NumericalIntegrator3D::tempVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary buffer for coordinates of refined mesh vertices. </p>
<p>The vector is used during the refinement procedure in case of fixed mesh refinement level, or is swapped alternatively with the main vector of coordinates of refined mesh vertices in case of adaptive error control procedure </p>

</div>
</div>
<a id="a8a6575f1d859ebbd681dbe90b4e86dfa" name="a8a6575f1d859ebbd681dbe90b4e86dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6575f1d859ebbd681dbe90b4e86dfa">&#9670;&#160;</a></span>verticesCellsNum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int2 NumericalIntegrator3D::verticesCellsNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current numbers of vertices and cells in the refined mesh stored on the host. </p>
<p>The value is initially assigned using the number in original mesh, then it is updated by the values from the device which are obtained in the mesh refinement procedure. 2 numbers are stored as 1 int2 value (.x refers to vertices, .y - to cells) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_numerical_integrator3d_8cuh_source.html">NumericalIntegrator3d.cuh</a></li>
<li>src/<a class="el" href="_numerical_integrator3d_8cu.html">NumericalIntegrator3d.cu</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_numerical_integrator3_d.html">NumericalIntegrator3D</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
